import { Hono } from "hono";
import { stream } from "hono/streaming";

import { createOpenAI } from "@ai-sdk/openai";
import { streamText, generateText } from "ai";
import { Redis } from "@upstash/redis";

import { db } from "@/db";
import { auth } from "../lib/auth";
import { message as dbMsg, message } from "@/db/schema/message";
import { eq, isNotNull } from "drizzle-orm";

import { v4 as uuidv4 } from "uuid" //delete it asap
import type { MsgIdMap } from "@/lib/get-set-client";
import { addClientId, removeClientId, processMsgIdMap } from "@/lib/get-set-client";


const aiRoute = new Hono<{
  Variables: {
    user: typeof auth.$Infer.Session.user | null;
    session: typeof auth.$Infer.Session.session | null;
  };
}>();

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

const connectedClients: MsgIdMap = {}


const openai = createOpenAI({
  apiKey: process.env.OPENAI_API,
});

aiRoute.get("/models", async (c) => {
  const modelList = await db.query.llms.findMany({
    with: {
      models: true,
    },
  });
  return c.json(modelList, 200);
});



aiRoute.post("/generate", async (c) => {
  const {messages, id, clientId} = await c.req.json();
  const userId = c.get("user")?.id;
  const userLastInput = messages[messages.length - 1].content
  const userLastInputId = "usr-" + "" + messages[messages.length - 1].id
  const generateMsgId = "msg-" + "" + uuidv4()

  // id ->thread Id, while chat id;  msgId/generated msg id ->  liek id for eache single msg
  addClientId(connectedClients, id,  clientId)



  if (!messages) {
    return c.json({ error: "Prompt is required" }, 400);
  }

  if (!userId) {
    return c.json({ error: "User undefined" }, 404);
  }


  await redis.publish(`chat:${id}`, JSON.stringify({role: "user", content: userLastInput, id: userLastInputId, timestamp: new Date().toISOString(), type: "user_input", chatId: id}))



  try {
    let wholeSentence = ""
    const code = streamText({
      // model: openai("gpt-4o-mini-2024-07-18"),
      model: openai("gpt-4.1-nano"),
      system: `you are a ai assistant name Gass you are 10 days old and you will only answer what is asked by the user nothing more nothing less.`,
      messages: messages,
      onFinish: async ({ text, request}) => {
        const userMessage = messages[messages.length - 1];
        const metaDataBody = request.body;
        const msgs = JSON.parse(metaDataBody!);
        const msgsLen = msgs["messages"].length;

        // save the data in upstash redis
        const pipeline = redis.pipeline();

        pipeline.lpush(
          `chat:${id}:messages`,
          JSON.stringify({
            role: "user",
            id: userLastInputId,
            content: userMessage.content,
            timestamp: Date.now(),
          })
        );

        pipeline.lpush(
          `chat:${id}:messages`,
          JSON.stringify({
            role: "assistant",
            id:generateMsgId,
            content: text,
            timestamp: Date.now(),
          })
        );

        await pipeline.exec();

        // save the saved message refference in the user mssage column
        const newMsg: typeof dbMsg.$inferInsert = {
          id: id,
          userId: userId,
          createdAt: new Date(),
          updatedAt: new Date(),
        };
        await db
          .insert(dbMsg)
          .values(newMsg)
          .onConflictDoUpdate({
            target: dbMsg.id,
            set: {
              updatedAt: new Date(),
            },
          });

          // generate title for new chat/message array/ convo
        // 0-2, 3 msg  means, just first msg is generated by the ai now we will generate the title save it in the backed 0: system, 1: user; 2:asssistent;
        if (msgsLen === 2) {
          const { text } = await generateText({
            // model: openai("gpt-4o-mini-2024-07-18"),
            model: openai("gpt-4.1-nano"),
            prompt: `Im providing you with the content; please generate a concise, on-point title of fewer than 56 characters. You must follow this. Content: ${msgs.messages[1].content}, and if the text you generated is undefined types or sometjing which dont have some meaning in the content context then generate again and this time ue context2: ${msgs.messages[0].content}; ## DO not use bot the content`,
          });
          await db.update(dbMsg).set({title:text, updatedAt: new Date()}).where(eq(dbMsg.id, id))

        }
        await redis.publish(`chat:${id}`, JSON.stringify({role: "assistant", id: generateMsgId, content: wholeSentence, timestamp: new Date().toISOString(), type: "chat_completed", chatId: id}))

      },
      onChunk: async({chunk}) => {
        wholeSentence += chunk.textDelta
        await redis.publish(`chat:${id}`, JSON.stringify({role: "assistant", id:generateMsgId, content: wholeSentence, timestamp: new Date().toISOString(), type: "chat_streaming", chatId: id}))

      }
    });
    c.header("X-Vercel-AI-Data-Stream", "v1");
    c.header("Content-Type", "text/plain; charset=utf-8");
    c.header("Content-Encoding", "none");

    return stream(c, (stream) => stream.pipe(code.toDataStream()));
  } catch (error: any) {
    console.error("Err in the route", error);
    return c.json(
      { error: error.message || "Filed to generate reponse" },
      500
    );
  }
})

aiRoute.get('/stream/:chatId', async (c) => {
  const chatId = c.req.param('chatId');
  const clientId = c.req.queries('clientId')?.[0];
  
  if (!clientId) {
    return c.text('Client ID is required', 400);
  }

  const setKey = `chat:${chatId}`;
  const upstashUrl = `${process.env.UPSTASH_REDIS_REST_URL}/subscribe/${setKey}`;


  try {
    // Fetch SSE stream from Upstash Redis REST API
    const upstashResponse = await fetch(upstashUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.UPSTASH_REDIS_REST_TOKEN}`,
        'Accept': 'text/event-stream',
      },
    });

    if (!upstashResponse.ok) {
      return c.text('Failed to subscribe to Upstash Redis', 500);
    }

    const upstashStream = upstashResponse.body;
    const initialMessage = "data:"

    // Create a combined stream: initial message followed by Upstash stream
    let upstashReader = null;
    let isControllerClosed = false;
    
    const combinedStream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();

        try {
          // Send initial message
          if (!isControllerClosed) {
            controller.enqueue(encoder.encode(initialMessage));
          }
          
          // Get the reader inside the ReadableStream
          upstashReader = upstashStream.getReader();
          
          while (true) {
            const { done, value } = await upstashReader.read();
            if (done) break;
            
            // Check if controller is still open before enqueueing
            if (!isControllerClosed) {
              controller.enqueue(value);
            } else {
              break; // Exit if controller is closed
            }
          }
        } catch (error) {
          console.error('Stream reading error:', error);
          if (!isControllerClosed) {
            try {
              controller.error(error);
              isControllerClosed = true;
            } catch (e) {
              // Controller might already be closed
              console.error('Error closing controller:', e);
            }
          }
        } finally {
          // Clean up reader
          if (upstashReader) {
            try {
              upstashReader.releaseLock();
            } catch (e) {
              console.error('Error releasing reader lock:', e);
            }
            upstashReader = null;
          }
          
          // Close controller if not already closed
          if (!isControllerClosed) {
            try {
              controller.close();
              isControllerClosed = true;
            } catch (e) {
              console.error('Error closing controller:', e);
            }
          }
          removeClientId(connectedClients, chatId, clientId);
          console.log('Stream closed for client:', clientId);
        }
      },
      
      async cancel() {
        console.log('Stream cancelled for client:', clientId);
        isControllerClosed = true; // Mark as closed to prevent further operations
        
        try {
          if (upstashReader) {
            // Cancel the reader first, then release the lock
            try {
              await upstashReader.cancel();
            } catch (e) {
              // Reader might already be cancelled, that's ok
              console.log('Reader already cancelled or errored:', e.message);
            }
            
            try {
              upstashReader.releaseLock();
            } catch (e) {
              // Lock might already be released, that's ok
              console.log('Lock already released:', e.message);
            }
            
            upstashReader = null;
          }
          
          // Now we can cancel the original stream
          try {
            await upstashStream?.cancel();
          } catch (e) {
            // Stream might already be cancelled, that's ok
            console.log('Stream already cancelled:', e.message);
          }
        } catch (error) {
          console.error('Error during cancellation:', error);
        }
        
        removeClientId(connectedClients, chatId, clientId);
      }
    });

    // Return the SSE stream with appropriate headers
    return new Response(combinedStream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
        'Access-Control-Allow-Origin': 'http://localhost:5173',
        'Access-Control-Allow-Credentials': 'true',
      },
    });

  } catch (error) {
    console.error('SSE Route error:', error);
    return c.text('Internal server error', 500);
  }
});

// Convert this into sse 
/**
 * Each client is one newtab/window we are tarcking no of opend tabs, and select the randpm client for the perticulat msg/thread 
 * connected clients: {msgId123: {cliet1/tab1, client2, client3}, msgId345: {cliet1/tab1, client2, client3}} 
 * processedMsgID: return {msgId123:client1, msgId455:client5Id}
 * 
 * it will help to store the data localy and slove the dublication of data by same smg with dofferent client by givving power to only one primary client to sav the data in teh device
 * return with one client/primary client 
 */
aiRoute.get('/connected-clients', async(c)=>{
  return c.json({"connectedClients": processMsgIdMap(connectedClients)}, 200)

})


aiRoute.get('/threads', async(c)=>{
  const currentUserId = c.get("user")?.id
  if(!currentUserId){
    return c.json({error: "Unauthorized User"}, 401)
  }
  try{
    const threads = await db.query.message.findMany({
      where: (message, {eq, and})=>
        and(
          eq(message.userId, currentUserId),
          isNotNull(message.title)
        ),
        orderBy: (message, { desc }) => [desc(message.updatedAt)],
        columns: {
          id:true,
          title:true,
          updatedAt:true
        },
        limit:20
    })
    return c.json({ threads }, 200);
  }
  catch(error:any){
    console.log("rrr in thred--", error)
    return c.json(
      {error: error.message || "Error while getting the generated threads"}
    )
  }
})


aiRoute.delete('delete-thread/:threadId', async(c)=>{
  const threadId = c.req.param("threadId")
  const currentUserId = c.get("user")?.id
  console.log(threadId, currentUserId)
  if(!currentUserId){
    return c.json({error: "Unauthorized User"}, 401)
  }

  try{
    const msg = await db.query.message.findFirst({
      where: (message, {eq})=> eq(message.id, threadId),
    })
    if (!msg) {
      return c.json({ error: 'Thread not found' }, 404);
    }

    if (msg.userId !== currentUserId) {
      return c.json({ error: 'Unauthorized' }, 403);
    }
    
    await db.delete(message).where(eq(message.id, threadId))
    return c.json({message: "Thread deleted successfuly"}, 200)

  }catch(error:any){
    console.log(error)
    return c.json({error: error.message || "Error while deleting the thread"}, 500)
  }
})
// get/threadId "" varify uuid4 f not return 404 

aiRoute.get('thread/:threadId', async(c)=>{
   const threadId = c.req.param("threadId")
  const currentUserId = c.get("user")?.id
  console.log(threadId, currentUserId)
  if(!currentUserId){
    return c.json({error: "Unauthorized User"}, 401)
  }

    const msg = await db.query.message.findFirst({
      where: (message, {eq})=> eq(message.id, threadId),
    })
    if (!msg) {
      return c.json({ error: 'Thread not found' }, 404);
    }

    if (msg.userId !== currentUserId) {
      return c.json({ error: 'Unauthorized' }, 403);
    }
  const threads = await redis.lrange(`chat:${threadId}:messages`, 0, -1)
  const chats = (Array.isArray(threads) ? threads : Object.values(threads as string))
  .map(thd => (thd!))
  .reverse(); // Reverse since lpush adds to beginning

  return c.json({chats})
})
export { aiRoute };
