import { Hono } from "hono";
import { stream } from "hono/streaming";

import { createOpenAI } from "@ai-sdk/openai";
import { streamText, generateText } from "ai";
import { Redis } from "@upstash/redis";

import { db } from "@/db";
import { auth } from "../lib/auth";
import { message as dbMsg, message } from "@/db/schema/message";
import { eq, isNotNull } from "drizzle-orm";

const aiRoute = new Hono<{
  Variables: {
    user: typeof auth.$Infer.Session.user | null;
    session: typeof auth.$Infer.Session.session | null;
  };
}>();

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!,
});

const openai = createOpenAI({
  apiKey: process.env.OPENAI_API,
});

aiRoute.get("/models", async (c) => {
  const modelList = await db.query.llms.findMany({
    with: {
      models: true,
    },
  });
  return c.json(modelList, 200);
});

aiRoute.post("/generate", async (c) => {
  const { messages, id } = await c.req.json();
  const userId = c.get("user")?.id;

  if (!messages) {
    return c.json({ error: "Prompt is required" }, 400);
  }

  if (!userId) {
    return c.json({ error: "User undefined" }, 404);
  }

  try {
    const code = streamText({
      model: openai("gpt-4.1-nano"),
      system: `you are a ai assistant name Gass you are 10 days old and you will only answer what is asked by the user nothing more nothing less.`,
      messages: messages,
      onFinish: async ({ text, request }) => {
        const userMessage = messages[messages.length - 1];
        const metaDataBody = request.body;
        const msgs = JSON.parse(metaDataBody!);
        const msgsLen = msgs["messages"].length;

        // save the data in upstash redis
        const pipeline = redis.pipeline();

        pipeline.lpush(
          `chat:${id}:messages`,
          JSON.stringify({
            role: "user",
            content: userMessage.content,
            timestamp: Date.now(),
          })
        );

        pipeline.lpush(
          `chat:${id}:messages`,
          JSON.stringify({
            role: "assistant",
            content: text,
            timestamp: Date.now(),
          })
        );

        await pipeline.exec();

        // save the saved message refference in the user mssage column
        const newMsg: typeof dbMsg.$inferInsert = {
          id: id,
          userId: userId,
          createdAt: new Date(),
          updatedAt: new Date(),
        };
        await db
          .insert(dbMsg)
          .values(newMsg)
          .onConflictDoUpdate({
            target: dbMsg.id,
            set: {
              updatedAt: new Date(),
            },
          });

          // generate title for new chat/message array/ convo
        // 0-2, 3 msg  means, just first msg is generated by the ai now we will generate the title save it in the backed 0: system, 1: user; 2:asssistent;
        if (msgsLen === 2) {
          const { text } = await generateText({
            model: openai("gpt-4o-mini-2024-07-18"),
            prompt: `Im providing you with the content; please generate a concise, on-point title of fewer than 56 characters. You must follow this. Content: ${msgs.messages[1].content}, and if the text you generated is undefined types or sometjing which dont have some meaning in the content context then generate again and this time ue context2: ${msgs.messages[0].content}; ## DO not use bot the content`,
          });
          await db.update(dbMsg).set({title:text, updatedAt: new Date()}).where(eq(dbMsg.userId, userId))
        }
      },
    });
    c.header("X-Vercel-AI-Data-Stream", "v1");
    c.header("Content-Type", "text/plain; charset=utf-8");
    c.header("Content-Encoding", "none");

    return stream(c, (stream) => stream.pipe(code.toDataStream()));
  } catch (error: any) {
    console.error("Err in the route", error);
    return c.json(
      { error: error.message || "Filed to generate reponse" },
      500
    );
  }
});
;

aiRoute.get('/threads', async(c)=>{
  const currentUserId = c.get("user")?.id
  if(!currentUserId){
    return c.json({error: "Unauthorized User"}, 401)
  }
  try{
    const threads = await db.query.message.findMany({
      where: (message, {eq, and})=>
        and(
          eq(message.userId, currentUserId),
          isNotNull(message.title)
        ),
        orderBy: (message, { desc }) => [desc(message.updatedAt)],
        columns: {
          id:true,
          title:true,
          updatedAt:true
        }
    })
    return c.json({ threads }, 200);
  }
  catch(error:any){
    return c.json(
      {error: error.message || "Error while getting the generated threads"}
    )
  }
})

export { aiRoute };
